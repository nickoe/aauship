\chapter{Velocity and Angle estimation}
To give a better position estimate which can be fed to the controller as well, the different data collected from the sensors mounted are put through a Kalman filter. This filter takes the different measurements as inputs, and uses these to give a better estimate of the position, rather than the quite noisy measurements taken using just the raw \ac{GPS} data. 

To develop such a filter, the model of the ship is to be computed, as well as a mapping of the different inputs and outputs to the system. The model of the forward and sidewards case (surge and sway) are the same as for the discrete system. 

\subsection{State model}
The state model is used as a base for computing the influence the different inputs have on the system. The matrix is the same as the $\vec{A}$ matrix used to describe the state space representation of the system. The general state expression is given as:
\begin{align}
\vec{x}(k) = \vec{\Phi}(k)\vec{x}(k-1) + \vec{w}(k)
\end{align}
\noindent Where:
\begin{ffk}
$\vec{\Phi}(k)$ is the state matrix\\
$\vec{x}(k-1)$ is the last input to the system\\
$\vec{w}(k)$ is the driving noise (the system input)
\end{ffk}
In this case, the driving noise $\vec{w}(n)$ will be the inputs to the system, which can then be used to estimate the different states. The states to be estimated is the velocity $\dot{x}$, the angular velocity $\omega$ and the angle of the vessel in the local frame $\theta$. The driving noise (or input) can be defined as the $\vec{B}$ matrix in the state system, multiplied with the different inputs given to the system, namely $n_1$ and $n_2$. When inserted, the formula for the state model becomes:
\begin{align}
\vec{x}(k) = \vec{\Phi}(k)\vec{x}(k-1) + \vec{B}\cdot\vec{u}
\end{align}

\subsection{Observation model}
The observation model, is a model that models the different observations. In this case, the different observations are measured directly, as we can measure both the angular velocity, the angle and the velocity of the craft. The general formula for the observation model is given as:
\begin{align}
\vec{z}(k) = \vec{H}(k)\vec{x}(k) + \vec{v}(k)
\end{align}
\noindent Where:
\begin{ffk}
$\vec{H}(n)$ is the model linking the measurements to the observations\\
$\vec{v}(n)$ is the measurement noise on the sensors
\end{ffk}
The noise from the measurements is estimated using previous measurements which can be used to estimate the variance and the mean of the measurements. The noise can in general be seen as zero-mean Gaussian white noise processes, which makes for the assumption:
\begin{align}
\vec{w}(n) \sim \mathcal{N}(0,\sigma_Z^2)
\end{align}
As $\vec{x}(n)$ is a row vector, $\vec{w}(n)$ is also a row vector with the same dimension. This calls for different variances on the different noise additions, for each of the measurements. As the variance of the noise on the \ac{IMU} is a lot bigger than on the \ac{GPS}. As all the measurements are available directly, the $\vec{H}(n)$ matrix is equal to identity. Giving the final observation model:
\begin{align}
\vec{z}(n) = \vec{x}(n) + \vec{v}(n)
\end{align}

% Wouldn't it be a fair assumption that a GPS doesn't have zero-mean, but has a wandering mean that would wander over time? 

% Text about the vector Kalman filer
% Text about the covariance matrix of such a system
\subsection{The Covariance matrices}
As the Kalman filter is given as a vector Kalman filter, the covariance matrices is to be computed. The definition for a covariance matrix is given as:
\begin{align}
Cov(\vec{X},\vec{X}) = \text{E}\langle[\vec{X} - \vec{\mu}_X][\vec{X} - \vec{\mu}_X]^\text{T}\rangle
\end{align}
The covariance matrix is used to tune the Kalman filter, and weighs the different inputs according to the noise they experience. An assumption is to keep this constant. For the vector Kalman filter there are two noises added to the system, one depicts the measurement noise, and the other the system noise. The system noise is in this project considered the input to the system. This can therefore be seen as the covariance of the input signals to the ship. As seen in \todo{insert reference to worksheet once its done -rlc} the distributions of the input signal $\vec{u}(k)$ can be seen as:
\begin{align}
F \sim \mathcal{N}(5.3544,55)\\
\tau \sim \mathcal{N}(0,20)
\end{align}
The covariance of these inputs, are then multiplied with $\vec{B}$ to give the input to the system $\vec{w}(k)$. As the two inputs are independent, the covariance matrix collapses to a matrix with diagonal entries, which gives the following matrix:
\begin{align}
Cov(\vec{X},\vec{X})_{3,3} = \sigma_{F}\\
Cov(\vec{X},\vec{X})_{9,9} = \sigma_{\tau}
\end{align}
When the system is simulated it gives the following response for estimating the position.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/kalmana}
	\caption{Test to see if the Kalman filter estimates the position}
	\label{fig:kalmanA}
\end{figure}
\vref{fig:kalmanA} depicts how the system responds when running the measurements at the same sample rate. However - the \ac{GPS} only samples at 1Hz and the \ac{IMU} samples at 10Hz, the filter needs to be changed. The Kalman filter must account for this change, which can be done by setting the noise of the measurement to a high value, which in turn will reduce the Kalman gain to zero, or just set the Kalman gain to zero. Both methods provide different results, as the estimate would then converge towards the last fixed value, whilst setting it to zero, would make the system use the other measurements available to the filter, and thus given an estimate, rather than convergin towards a fixed value. 	

\begin{align}
\vec{x}(n+1) = \vec{\Phi}\cdot\vec{x}(n) = \begin{bmatrix}
1 & t_s & \frac{t_s^2}{2} & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & t_s & 0 & 0 & 0 & 0 & 0 & 0\\
0 & -\beta_X & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & t_s & \frac{t_s^2}{2} & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & t_s & 0 & 0 & 0\\
0 & 0 & 0 & 0 & -\beta_Y & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & t_s & \frac{t_s^2}{2}\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & t_s\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & -\beta_\omega & 0\\
\end{bmatrix}\begin{bmatrix}
x(n)\\
\dot{x(n)}\\
\ddot{x(n)}\\
y(n)\\
\dot{y(n)}\\
\ddot{y(n)}\\
\theta(n)\\
\omega(n)\\
\alpha(n)\\
\end{bmatrix}
\label{eq:matr}
\end{align}
In \vref{eq:matr} the system matrix is seen to be 3 individual systems. The inputs to the Kalman filter is seen as 
\todo{fix -rlc}


 will be a desired revolution speed of the two propellers. This generates a thrust forward, which will result in a velocity and if there is a difference between the two, then this will result in a torque, making the ship turn. The inputs can thus be given as:
\begin{align}
\vec{Z} = \begin{bmatrix}
0 & 0\\
0 & 0\\
\frac{1}{m} & 0\\
0 & 0\\
0 & 0\\
0 & 0\\
0 & 0\\
0 & 0\\
0 & \frac{1}{I}\\
\end{bmatrix}\begin{bmatrix}
F\\
\tau
\end{bmatrix}
\end{align}

On \vref{fig:revol} a test input to the system is plotted. The sequence is an alternating angle reference sequence, the angle is a sine curve. 
\begin{figure}[htbp]
	\centering
%	\includegraphics[width=\textwidth]{img/revol}
	\caption{Test input to the system}
	\label{fig:revol}
\end{figure}

As these cannot be measured accurately, we need to add noise to the input signals.

SETTING THE MEASUREMENT TO ZERO IF THERE IS NO SAMPLE to ensure that you still get a computation, without having a measurement - henvisning til Jespers første forelæsning!

Foreslag til Paper: Hvor langt ned kan man gå i sampling på GPS'en for at spare båndbredde, uden at miste præcision!

\subsection{Simulations of the filter}
% Text about linearizations / further computation.
Simulation of the Kalman filter have proven to provide an accurate estimate, however - the actual variances have to be measured. 

To avoid computational problems the Joseph Form of the Kalman Filter can be used. This ensures that the matrices used in the updating step is non-singular and positive definite. 

A little on the theory of Joseph Form.

\section{Position estimation}
During the development of the Kalman filter a lot or problems were discovered. One is to estimate the variances of the different measurement devies. The GPS delivers a position in latitude longitude format - which is converted into an x and y coordinate by rotating the entire system and shifting the local frame of the ship as a surface tangent to the earth. This will of course only be an estimate, but as the curvature of the earth is relatively small. The distance to the horizon can be estimated by $d \approx 3.57\sqrt{h}$ which on the ground, equals that the distance to the horizon is approximately 3.57 kilometers. As the areas to be measured are defined by a local bounding box - this area will to be defined to be smaller than 3.5 kilometers.

This section will contain the different things we've considered during the miniproject in Kalman filtering, and will be used to give a better estimate of the actual position (from the measurements implemented on the ship).

Below is a description of the measurable inputs to the system. These are obtained from a \ac{GPS} and a \ac{IMU} mounted on the ship.
Position and velocity from the \ac{GPS}: rotated coordinates (from LatLon to Local frame)
Linear acceleration from the \ac{IMU}: accelerometer
Angular acceleration from the \ac{IMU}: gyrometer
Angle from the \ac{IMU}: magnetometer (compass)

Estimating the bias of added wind and water current. As the wind and current shifts the ship around, and changes the torque to allow for a bias. This can be dealt with by extending the Kalman filter, to include these as measurements, and then subtracting these in the end result. This results in a filter that does not deal with the bias directly, but instead estimates without looking in to this. 

\begin{align}
\vec{A}_{ext} = \begin{bmatrix}
\vec{A}\\
\bar{\vec{b}}
\end{bmatrix}
\end{align}
\noindent Where:
\begin{ffk}
$\bar{\vec{b}}$ is the vector representing the bias in the x- and y-direction. 
\end{ffk}

\MATLAB plot indsættes af hvordan dette ser ud! (med og uden bias!).

The signal from the GPS can be seen as the actual position, plus some noise. 
