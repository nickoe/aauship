%% Simulation of Kalman Filter for Position Measurements (3-dimensional)
% CA1 - 730
% Nick Østergaard, Frederik Juul, Tudor Muresan, Rasmus L. Christensen and
% Attila Fodor

clc, clear all, close all

% The purpose of the Kalman filter is to estimate the true position given
% noisy measurements of the acceleration, velocity and position of the
% vessel. This is done throughout the rest of this paper. 

% All the data are generated by random noise - as measurements were unable
% to be obtained. And they are not fitted to any real velocity or
% measurement. This makes the modelled vessel sail "underwater" which could
% be due to wave motion. A more accurate model is to be developed before
% the filter is implemented in real life.

% All calculations are based on the vector Kalman filter equations in the
% lectures notes. 

% The purpose of the project is to measure depths of water, so using a GPS,
% ACCELEROMETER and the output velocity of the GPS, the actual track can be
% estimated using a Kalman filter. The important part of this is to sail in
% a straight line, and know the exact position of the depth measurements. 

%Simulation parameters
ts = .01;
N = 1000;
alphaX = 0.1; % Drag coefficient x-direction
alphaY = 0.9; % Drag coefficient y-direction
alphaZ = 0.9; % Drag coefficient z-direction

% The Observation model is defined as:
% X(n) = A(n)*Y(n-1) + W(n)
An = eye(9);
% Noise is generated further down, as this changes each iteration. 

% The system model is now defined as:
% Y(n) = H(n)*Y(n) + Z(n)
Hn = [1 0 0 ts 0 0 ((ts^2)/2) 0 0;...
      0 1 0 0 ts 0 0 ((ts^2)/2) 0;...
      0 0 1 0 0 ts 0 0 ((ts^2)/2);...
      0 0 0 1 0 0 ts 0 0;...
      0 0 0 0 1 0 0 ts 0;... 
      0 0 0 0 0 1 0 0 ts;...
      0 0 0 -alphaX 0 0 0 0 0;...
      0 0 0 0 -alphaY 0 0 0 0;...
      0 0 0 0 0 -alphaZ 0 0 0];
% Again, the noise is changed at each sample. 

% Initiation of the Kalman filter:
Ypred = zeros(9,N); % Prediction of Y
Xpred = zeros(9,N); % Prediction of X
Rpred = zeros(9,9,N); % Prediction of R
B = zeros(9,9,N); % Kalman filter gain B

Yupdate = zeros(9,N); % Update step of Y
Rupdate = zeros(9,9,N); % Update step of R

X = zeros(9,N);
Y = zeros(9,N);

varX = 0.3; % The different signal generation variances are defined in this. 
varY = 0.3; % They are set to be equal as the variances currently are unknown. 
varZ = 0.3; % 

% These variances are the driving signals, and can be changed to give a
% more accurate estimate of the system. To make these accurate, you would
% have to build a model of the noise the system would experience - rather
% than just generating a normal distribution of numbers. This noise
% represents for instance enviromental parameters (such as waves, wind and
% currents etc.). It can be seen on the plots that the system has trouble
% coping with the variances in the turning phases - which can be enhanced
% by changing the above. But this would result in a lower accuracy on the
% straight lines. 

varW = 0.001; % The variance of the different measurement instruments.

% The above represents the measurement accuracy of the different sensors
% mounted on the ship. If this is very high, the Kalman estimator will not
% be as good at estimating - and the filtered version of the signal, will
% look like its influenced by a lot of noise, which makes sense, as the
% signal is varying a lot!

for n = 2:1:N
            Zn = [zeros(1,6) randn(1,1)*sqrt(varX) randn(1,1)*sqrt(varY) randn(1,1)*sqrt(varZ)]'; % New samples are generated at each time step (inputs to the system).
            Wn = randn(9,1)*sqrt(varW); % Measuremnet noise (all the sensors are IID uncorrelated).
            Qz = [0 0 0 0 0 0 0 0 0;0 0 0 0 0 0 0 0 0;0 0 0 0 0 0 0 0 0;...
                0 0 0 0 0 0 0 0 0;0 0 0 0 0 0 0 0 0;0 0 0 0 0 0 0 0 0;...
                0 0 0 0 0 0 varX 0 0;0 0 0 0 0 0 0 varY 0;0 0 0 0 0 0 0 0 varZ]; % Covariance matrix
            Qw = eye(9)*varW;
        Y(:,n) = Hn*Y(:,n-1)+Zn;
        X(:,n) = An*Y(:,n)+Wn;
    Ypred(:,n) = Hn*Yupdate(:,n-1);
    Xpred(:,n) = An*Ypred(:,n);
  Rpred(:,:,n) = Hn*Rupdate(:,:,n-1)*Hn'+Qz;
      B(:,:,n) = (Rpred(:,:,n)*An')*inv(An*Rpred(:,:,n)*An'+Qw);
  Yupdate(:,n) = Ypred(:,n)+B(:,:,n)*(X(:,n)-Xpred(:,n));
Rupdate(:,:,n) = (eye(9)-B(:,:,n)*An)*Rpred(:,:,n);
end